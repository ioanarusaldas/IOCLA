Savu Ioana Rusalda 325CB
enunt:https://ocw.cs.pub.ro/courses/iocla/teme/tema-3

1. Analiza binarului - 20p
	FUNCTIA VULNERABILA:<print_flag> care se afla la adresa:080485b1

	Pentru a putea vedea codul din spatele executabilului am folosit comanda :
		obj -d -M intel nice > niceFile
	Dupa aceasta am cautat main-ul programului pentru a avea un punct de inceput.
	Am observat ca in main este apelata de mai multe ori functia  <print_flag> 
	de la adresa 080485b1.
	In aceasta functie esta apelata de mai multe ori functia <read@plt>.
		Pentru a vedea mai bine cum decurge programul am folosit gdb cu 
	extensia peda.Am incercat mai intai cateva payload-uri random si 
	am vazut ca nu se schimba nimic in decursul programului.
		Cu toate acestea am observat insa ca la un payload suficient de lung executia
	programului a generat Segmentation Fault ,acesta oprindu-se la comanda call eax.
	Astfel mi-am dat seama ca problema ar putea fi in continutul lui eax. Ultima comanda 
	care a modificat registrul fiind  mov eax,DWORD PTR [ebp+0xc].Prin urmare adresa de
	la ebp+0xc se modifica undeva.
		Cum pentru payloaduri mici programul afisa un mesaj iar pentru payloaduri mari 
	esecutia genera Segmentation Fault mi-am dat seama ca este vorba de suprascrierea
	adresei ebp+0xc.
		La fiecare apel al functiei <read@plt> functia <print_flag> aloca  
	functiei read o portiune pe stiva ,insa la un payload 
	sufiecient de mare aceasta zona va fi depasita iar alte valori aflate pe stiva
	vor fi suprascrise.
		In concluzie, functia vulnerabila este functia <print_flag> care se afla la adresa:080485b1,
	deoarece suprascrie o adresa necesara incheierii programului.

2. Spargerea binarului - 40p
	RASPUNS :	NICE_FLAG{77700e1f41b11b795a1011d23e86b130}

	Pentru spargerea binarului am urmarit fiecare secventa dinaintea apelului functiei <read@plt>.

								sub    esp,0x1b4
   0x8048607 <print_flag+86>:	mov    edx,esp
   0x8048609 <print_flag+88>:	push   0xab
   0x804860e <print_flag+93>:	push   edx
   0x804860f <print_flag+94>:	push   0x0
   0x8048611 <print_flag+96>:	call   0x8048340 <read@plt>

   0x804861b <print_flag+106>:	sub    esp,0x1dc
=> 0x8048621 <print_flag+112>:	mov    edx,esp
   0x8048623 <print_flag+114>:	push   0x169
   0x8048628 <print_flag+119>:	push   edx
   0x8048629 <print_flag+120>:	push   0x0
   0x804862b <print_flag+122>:	call   0x8048340 <read@plt>

	0x8048635 <print_flag+132>:	sub    esp,0x172
=> 0x804863b <print_flag+138>:	mov    edx,esp
   0x804863d <print_flag+140>:	push   0x9e
   0x8048642 <print_flag+145>:	push   edx
   0x8048643 <print_flag+146>:	push   0x0
   0x8048645 <print_flag+148>:	call   0x8048340 <read@plt>

    0x804864f <print_flag+158>:	sub    esp,0xa0
   => 0x8048655 <print_flag+164>:	mov    edx,esp
      0x8048657 <print_flag+166>:	push   0x170
      0x804865c <print_flag+171>:	push   edx
      0x804865d <print_flag+172>:	push   0x0
      0x804865f <print_flag+174>:	call   0x8048340 <read@plt>

      Cum 0xa0 in decimal este 160 si 0x170 este 368 memoria alocata nu este suficienta
si se vor suprascrie alte valori salvate pe stiva.
Payloadul trebuie sa contina atatea caractere astfel incat sa nu depaseasca zona alocata.Pentru aceasta am 
calculat caracterele necesare fiecarei apel al functiei read. 
	Adica: 0xab + 0x169 +0x9e +0xa0 =0x352 transformat in zecimal reprezinta 850 de caractere. 
	Comanda mov eax,DWORD PTR [ebp+0xc] muta valoarea aflata la ebp+0xc. Cum 0xc reprezinta numarul 12 in
decimal am mai adaugat la payload 12 caractere ,in total 862.Dupa aceste caractere le-am transforamt in hexa
si am continuat cu adresa functiei <print_flag> si anume 080485b1 dar in sistem little-endian,adica b1850408.
Astfel suprascrierea s-a realizat exact cu adresa necesara pentru afisarea mesajului corect.

3. Spargerea binarului v2 - 40p
RASPUNS:	NAUGHTY_FLAG{88b03f3645e15e2dbc47c52dcfd6d467}

	Pentru acest exercitiu am procedat asemanator exercitiului 2.
	Si am urmarit aceleasi secvente de tipul :

	0x8048601 <print_flag+80>:	sub    esp,0x130
   0x8048607 <print_flag+86>:	mov    edx,esp
=> 0x8048609 <print_flag+88>:	push   0x92
   0x804860e <print_flag+93>:	push   edx
   0x804860f <print_flag+94>:	push   0x0
   0x8048611 <print_flag+96>:	call   0x8048340 <read@plt>
   0x8048616 <print_flag+101>:	cmp    DWORD PTR [ebp-0xd9],0xaaba0597

   La constructia payloadului am avut grija sa suprascriu la adresele indicate in secventele de tipul:
 DWORD PTR [ebp-0xd9],0xaaba0597 (spre exemplu  la ebp-0xd9 cu 0xaaba0597,dar in little-endian).Pentru
 asta a trebuit sa calculez numarul de caratere din fata adresei si dupa adresa astfel :
 	*in fata adresei 0x130-0xd9 =0x57 in decimal reprezentand 87 de caractere aleatoare
 	*dupa adresa 0x92 este 146 in decimal ,atunci 146-(87+4)=55 de caractere aleatoare
 	Astfel pentru prima secventa payloadul meu contine 87 de caractere + adresa 9705baaa+55 de caractere aleatoare.
 La fel am procedat si pentru restul secventelor:
 	*6 caractere aleatoare + adresa e6866ce7 +151 caractere aleatoare
 	*91 caractere aleatoare + adresa b6d071b4 +31 caractere aleatoare
 	*156 caractere aleatoare + adresa adf45c9d +30 caractere aleatoare
 	*96 caractere aleatoare+ adresa e6e517e5 +65 caracetre aleatoare
La ultima secventa,asemeni taskului 2 am avut grija sa suprascriu cu adresa din program necesara afisarii mesajului
corect. Astfel : 168 caractere aleatoare + adresa 561b4f6b+282 caractere aleatoare +adresa lui <print_flag> b1850408.

NOTA:
	Cand am mai intampinat probleme am folosit in gdb si comanda x/1000xb $esp pentru a vedea pe ce octet am pus adresele
si pentru a ma verifica.


 	




